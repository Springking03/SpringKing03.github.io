<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bắn cung cứu người yêu</title>

<link href="https://fonts.googleapis.com/css2?family=Fira+Sans:wght@300;400;600;800;900&display=swap" rel="stylesheet">
<style>
  :root{
    --cream:#F4EEDC; --paper:#FFF8E8; --olive:#586A4A; --olive2:#45563D;
    --ink:#24301f; --stroke:rgba(0,0,0,.06); --shadow:0 14px 34px rgba(0,0,0,.18);
    --rose:#ff6b81;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  body{
    font-family:"Fira Sans",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background:var(--cream); color:var(--ink);
    display:flex; align-items:center; justify-content:center; padding:16px;
  }
  .frame{
    width:min(1100px,96vw);
    background:linear-gradient(180deg,var(--paper),#FFF3D8);
    border:1px solid var(--stroke); border-radius:28px; box-shadow:var(--shadow);
    padding:16px; position:relative; overflow:hidden;
  }
  header{
    display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:10px;
  }
  .title{font-weight:900; color:var(--olive2); letter-spacing:.02em}
  .meta{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .badge{background:var(--olive); color:#fff; padding:6px 12px; border-radius:12px; font-weight:800}
  .tip{font-size:13px; color:#586651; opacity:.95}

  .stage-wrap{display:grid; place-items:center}
  canvas#stage{
    width:min(1000px,94vw); height:calc(min(1000px,94vw)*0.56);
    background:#f7f1df; border-radius:20px; border:1px solid rgba(0,0,0,.06);
    box-shadow:inset 0 0 0 6px rgba(233,223,194,.75), 0 10px 24px rgba(0,0,0,.12);
    display:block;
  }

  /* overlays */
  .overlay{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.28); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); z-index:5;
  }
  .dialog{
    background:#fff; border-radius:22px; padding:22px 24px; text-align:center; width:min(620px,92vw);
    box-shadow:0 18px 46px rgba(0,0,0,.22); border:1px solid rgba(0,0,0,.06);
  }
  .dialog h2{ font-weight:900; color:var(--olive2); margin-bottom:6px; font-size:24px }
  .dialog p{ color:#5a6a51; margin-bottom:14px }
  .actions{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap }
  .btn{
    padding:12px 16px; border-radius:14px; border:none; font-weight:800; cursor:pointer;
    box-shadow:0 10px 22px rgba(88,106,74,.18);
  }
  .btn.primary{ background:linear-gradient(180deg, var(--olive), var(--olive2)); color:#fff }
  .btn.ghost{ background:#f0e8cf; color:#33402f }

  /* Quiz */
  .quiz h3{font-size:20px; color:var(--olive2); margin-bottom:10px; font-weight:900}
  .choices{display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:6px}
  .choice{
    border:1px solid rgba(0,0,0,.08); background:#fff; border-radius:14px; padding:12px;
    cursor:pointer; font-weight:800; text-align:center;
    box-shadow:0 6px 14px rgba(0,0,0,.08);
  }
  .choice:hover{ background:#f8f3e4 }

  /* talker (xuanhoang nói khi phát voice) */
  .talker{
    position:absolute; right:24px; bottom:24px; display:flex; align-items:center; gap:10px;
  }
  .talker .bubble{
    background:#ffffff; border:1px solid rgba(0,0,0,.06); border-radius:14px; padding:8px 12px; color:#586651;
    box-shadow:0 8px 18px rgba(0,0,0,.1); font-weight:700;
  }
  .talker .face{
    width:74px; height:74px; border-radius:50%; overflow:hidden; border:2px solid rgba(255,255,255,.9);
    box-shadow:0 8px 18px rgba(0,0,0,.18);
    transform:translateZ(0);
  }
  .talker .face>img{width:100%; height:100%; object-fit:cover}
  .talking{ animation: talk-wiggle .6s ease-in-out infinite }
  @keyframes talk-wiggle{
    0%{ transform:translateY(0) rotate(0) }
    25%{ transform:translateY(-2px) rotate(-2deg) }
    50%{ transform:translateY(0) rotate(0.8deg) }
    75%{ transform:translateY(-1px) rotate(-1.5deg) }
    100%{ transform:translateY(0) rotate(0) }
  }

  /* Kiss burst image */
  .hon{
    position:fixed; width:90px; height:90px; border-radius:50%; overflow:hidden;
    box-shadow:0 8px 18px rgba(0,0,0,.2); border:2px solid rgba(255,255,255,.9);
    transform:translate(-50%,-50%); z-index:9; pointer-events:none;
  }

  /* HELP bubble */
  .help{
    position:fixed; padding:6px 10px; border-radius:12px; background:#fff; color:#d83b3b; font-weight:900;
    border:1px solid rgba(0,0,0,.08); box-shadow:0 8px 16px rgba(0,0,0,.12);
    transform:translate(-50%,-50%); z-index:8; pointer-events:none;
  }

  audio{ display:none }
</style>
</head>
<body>
  <!-- Âm thanh -->
  <audio id="bgm" src="bgm.mp3" loop></audio>
  <audio id="shootSfx" src="shoot.mp3" preload="auto"></audio>
  <audio id="banSfx" src="ban.mp3" preload="auto"></audio>
  <audio id="hitSfx" src="hit.mp3" preload="auto"></audio>
  <audio id="voiceQ" src="05.mp3" preload="auto"></audio>
  <audio id="victorySong" src="victory.mp3" preload="auto"></audio>
  <audio id="chutSfx" src="chut.mp3" preload="auto"></audio>

  <div class="frame">
    <header>
      <div class="title">BẮN CUNG CỨU NGƯỜI YÊU</div>
      <div class="meta">
        <div class="badge">Quái còn: <span id="remain">5</span>/5</div>
        <div class="badge">Bắn trúng: <span id="hits">0</span></div>
        <div class="tip">Kéo & thả để bắn — mũi tên thật, bay vòng vòng rồi vẫn trúng 🎯</div>
      </div>
    </header>

    <div class="stage-wrap">
      <canvas id="stage" width="1000" height="560" aria-label="Sân bắn cung"></canvas>
    </div>

    <!-- bắt đầu -->
    <div class="overlay" id="startOverlay">
      <div class="dialog">
        <h2>Bắt đầu cứu người yêu chứ? 💘</h2>
        <p>Kéo dây cung theo bất kỳ hướng nào để ngắm. Lực kéo quyết định tốc độ mũi tên & độ “hề hề”.</p>
        <div class="actions">
          <button class="btn ghost" id="howBtn">Hướng dẫn</button>
          <button class="btn primary" id="startBtn">Bắt đầu</button>
        </div>
      </div>
    </div>

    <!-- hướng dẫn -->
    <div class="overlay" id="howOverlay" style="display:none">
      <div class="dialog">
        <h2>Cách chơi</h2>
        <p>Giữ chuột/ngón tay để kéo dây, thả ra để bắn. Mũi tên xoáy – lắc – rồi tự khóa mục tiêu. Trúng → quái rơi xuống đất (loại khỏi mục tiêu).</p>
        <div class="actions">
          <button class="btn primary" id="backToStart">Quay lại</button>
        </div>
      </div>
    </div>

    <!-- quiz -->
    <div class="overlay" id="quizOverlay" style="display:none">
      <div class="dialog quiz" style="position:relative">
        <h2 style="margin-bottom:8px">Bạn đã cứu được người yêu! 🥹💞</h2>
        <p id="quizLead" style="margin-bottom:10px;">Nghe câu hỏi nè…</p>
        <h3>Câu hỏi</h3>
        <div class="choices">
          <button class="choice" data-a="banhchung">Bánh chưng</button>
          <button class="choice" data-a="banhgiay">Bánh giày</button>
          <button class="choice" data-a="banhbao">Bánh bao</button>
          <button class="choice" data-a="tiramisu">Tiramisu Cake</button>
        </div>
        <div class="talker" id="talker" style="display:none">
          <div class="bubble">Mình nói nè…</div>
          <div class="face" id="talkFace"><img src="xuanhoang.png" alt="xuanhoang"/></div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ====== Audio ======
  const bgm = document.getElementById('bgm');
  const shootSfx = document.getElementById('shootSfx');
  const banSfx = document.getElementById('banSfx');
  const hitSfx = document.getElementById('hitSfx');
  const voiceQ = document.getElementById('voiceQ');
  const victorySong = document.getElementById('victorySong');
  const chutSfx = document.getElementById('chutSfx');

  // volumes
  bgm.volume   = 0.5;  // nhạc nền
  voiceQ.volume = 0.5; // 05.mp3 ở 50%
  victorySong.volume = 0.7;
  chutSfx.volume = 0.9;

  // Bắt đầu phát nhạc nền sau thao tác người dùng để tránh chặn autoplay
  const resumeAudio = () => { bgm.play().catch(()=>{}); window.removeEventListener('pointerdown', resumeAudio); };
  window.addEventListener('pointerdown', resumeAudio);

  // ====== Overlays ======
  const startOverlay = document.getElementById('startOverlay');
  const howOverlay = document.getElementById('howOverlay');
  const quizOverlay = document.getElementById('quizOverlay');
  const quizLead = document.getElementById('quizLead');
  const talker = document.getElementById('talker');
  const talkFace = document.getElementById('talkFace');

  document.getElementById('howBtn').onclick = ()=>{ startOverlay.style.display="none"; howOverlay.style.display="flex"; };
  document.getElementById('backToStart').onclick = ()=>{ howOverlay.style.display="none"; startOverlay.style.display="flex"; };
  document.getElementById('startBtn').onclick = ()=>{
    startOverlay.style.display="none";
    startGame();           // ✅ bật vòng lặp game
    bgm.play().catch(()=>{});
  };

  // ====== Canvas & world ======
  const cvs = document.getElementById('stage');
  const ctx = cvs.getContext('2d');
  const W = cvs.width, H = cvs.height;
  const GROUND_Y = H - 60, SKY = '#f7f1df', GROUND = '#e9dfc4';

  const headArcher = new Image(); headArcher.src = 'vietanh.png';
  const headLover  = new Image(); headLover.src = 'xuanhoang.png';

  const archer = { x: 130, y: GROUND_Y-110, w: 52, h: 112, aim:false, pull:0, aimVec:{x:120,y:-30}, drawHand:{x:0,y:0} };
  const cage = { x: W-190, y: GROUND_Y-170, w: 130, h: 170, open:false };
  const lover = { x: cage.x+65, y: cage.y+128, freed:false, jumpAmp:0 };

  const ENEMY_COUNT = 5;
  const enemies = [];
  for(let i=0;i<ENEMY_COUNT;i++) enemies.push(makeEnemy(i));
  function makeEnemy(i){
    const y = 90 + i*50 + Math.random()*30;
    const x = W*0.45 + Math.random()*W*0.45;
    return { x, y, r: 18+Math.random()*8, t: Math.random()*6.28, vx:(Math.random()<.5?-1:1)*(0.6+Math.random()*0.6),
             alive:true, falling:false, landed:false, vy:0, rot:0 };
  }

  const arrows=[];
  let hits=0;
  const remainEl = document.getElementById('remain');
  const hitsEl = document.getElementById('hits');
  remainEl.textContent = ENEMY_COUNT; // ✅ hiển thị đúng ngay từ đầu

  // ====== Input ======
  let pId=null;
  cvs.addEventListener('pointerdown', e=>{
    const p = local(e);
    if(p.x < 320 && p.y > archer.y-160){
      pId=e.pointerId; cvs.setPointerCapture(pId);
      archer.aim=true; archer.pull=0; archer.aimStart=p;
      const anchor = { x: archer.x+24, y: archer.y-26 };
      archer.drawHand = anchor;
    }
  });
  cvs.addEventListener('pointermove', e=>{
    if(archer.aim && e.pointerId===pId){
      const p = local(e);
      const anchor = { x: archer.x+24, y: archer.y-26 };
      const dx = p.x - anchor.x, dy = p.y - anchor.y;
      const len = Math.min(200, Math.hypot(dx,dy)), ang = Math.atan2(dy,dx);
      archer.pull = len;
      archer.aimVec = { x: Math.cos(ang)*Math.max(60, len), y: Math.sin(ang)*Math.max(30, len*0.7) };
      archer.drawHand = { x: anchor.x + Math.cos(ang)*len, y: anchor.y + Math.sin(ang)*len };
    }
  });
  cvs.addEventListener('pointerup', e=>{
    if(archer.aim && e.pointerId===pId){
      fireArrow();
      archer.aim=false; archer.pull=0; cvs.releasePointerCapture(pId); pId=null;
    }
  });
  function local(e){ const r = cvs.getBoundingClientRect(); return { x:(e.clientX-r.left)*(W/r.width), y:(e.clientY-r.top)*(H/r.height) }; }

  // ====== Fire arrow ======
  function fireArrow(){
    const targets = enemies.filter(e=>e.alive && !e.falling && !e.landed);
    if(!targets.length) return;

    const from = { x: archer.x+42, y: archer.y-26 };
    const guess = archer.aimVec || {x:120,y:-30};
    const aimY = from.y + guess.y;
    let target = targets.reduce((best,e)=>{ const d=Math.abs(e.y-aimY); return (!best||d<best.d)?{e,d}:best; }, null).e;

    const c1 = { x: from.x + guess.x*0.35, y: from.y + guess.y*0.35 - 80 };
    const c2 = { x: from.x + guess.x*0.85, y: from.y + guess.y*0.85 + 90 };
    const to = { x: target.x, y: target.y };

    const pullNorm = Math.min(1, (archer.pull||100)/200);
    const speed   = 0.010 + pullNorm*0.018;
    const wobAmp  = 26 + pullNorm*22;
    const wobFreq = 6 + Math.random()*4;

    arrows.push({ t:0, from, c1, c2, to, targetRef:target, speed, wobAmp, wobFreq, done:false, lastPos:{...from}, angle:0 });

    // âm thanh khi bắn
    try{ shootSfx.currentTime=0; shootSfx.play().catch(()=>{});}catch{}
    setTimeout(()=>{ try{ banSfx.currentTime=0; banSfx.play().catch(()=>{});}catch{} }, 30);
  }

  // ====== Loop ======
  let last=0, running=false, victory=false, tVictory=0, heartsT=0;
  let hugging=false, hugStart=0, kissShown=false, quizShown=false;
  let helpTimer = 0;

  function loop(ts){
    if(!last) last=ts; const dt=(ts-last)/16.67; last=ts;

    // enemies
    enemies.forEach(en=>{
      if(!en.alive) return;
      if(en.falling){
        if(!en.landed){
          en.vy += 0.7*dt; en.y += en.vy*dt; en.rot += 0.09*dt;
          if(en.y + en.r >= GROUND_Y){ en.y = GROUND_Y - en.r; en.landed = true; en.vy = 0; }
        }
        return;
      }
      en.t += 0.04*dt;
      en.x += en.vx*dt*1.2;
      en.y += Math.sin(en.t)*0.8*dt*6;
      if(en.x < W*0.40) en.x = W*0.95;
      if(en.x > W*0.95) en.x = W*0.40;
    });

    // arrows
    arrows.forEach(a=>{
      if(a.done) return;
      a.t += a.speed*dt;
      if(a.t>0.55){ const trg=a.targetRef; if(trg&&trg.alive&&!trg.falling&&!trg.landed){ a.to.x=trg.x; a.to.y=trg.y; } }
      if(a.t>=1){ hit(a); a.done=true; }
    });

    // HELP bubbles before rescued
    if(!cage.open && !lover.freed){
      if(ts - helpTimer > 1000){ helpTimer = ts; spawnHelpBubble(); }
    }

    lover.jumpAmp *= 0.92;

    // draw
    draw();

    // victory flow: ôm -> hôn 1 tí -> quiz + voice + mặt nói/lắc
    if(victory){
      if(!hugging){
        if(!lover.freed){ lover.freed=true; lover.x=cage.x + cage.w/2; }
        lover.x -= 2.6;
        if(lover.x <= archer.x+66){ hugging=true; hugStart=performance.now(); }
      } else {
        drawHug();
        if(ts - heartsT > 110){ heartsT = ts; spawnHeart(archer.x+60, archer.y-46); }
        if(!kissShown){
          kissShown = true;
          try{ chutSfx.currentTime=0; chutSfx.play().catch(()=>{});}catch{}
          honBurst(archer.x+64, archer.y-6);
        }
        if(!quizShown && ts - hugStart > 1600){
          quizShown = true;
          showQuiz();
        }
      }
    }

    if(running) requestAnimationFrame(loop);
  }

  // ====== Draw ======
  function draw(){
    ctx.fillStyle = SKY; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#ffffffb0';
    for(let i=0;i<3;i++){ const cx = (i*320 + (performance.now()/30)%W); cloud(cx%W, 80+i*30); }
    ctx.fillStyle = GROUND; ctx.fillRect(0,GROUND_Y,W,H-GROUND_Y);

    drawCageAndLover();
    enemies.forEach(en=>{ if(en.alive) drawEnemy(en); });
    drawArcher();
    arrows.forEach(a=>{ if(!a.done) drawArrow(a); });
    if(archer.aim) drawNockedArrow();
  }

  function cloud(x,y){ ctx.beginPath(); ctx.arc(x,y,22,0,Math.PI*2); ctx.arc(x+26,y+6,26,0,Math.PI*2); ctx.arc(x+56,y-2,18,0,Math.PI*2); ctx.fill(); }

  function drawHead(img, cx, cy, r){
    const size=r*2;
    if(img.complete&&img.naturalWidth){
      ctx.save(); ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.clip();
      ctx.drawImage(img,cx-r,cy-r,size,size); ctx.restore();
      ctx.strokeStyle='rgba(255,255,255,.85)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
    } else { ctx.fillStyle='#d9b99a'; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); }
  }
  function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

  function drawArcher(){
    ctx.fillStyle = '#7c8f6c'; roundRect(archer.x, archer.y, archer.w, archer.h, 10); ctx.fill();
    ctx.strokeStyle='#33402f'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(archer.x+18, archer.y+archer.h); ctx.lineTo(archer.x, archer.y+archer.h+34);
    ctx.moveTo(archer.x+34, archer.y+archer.h); ctx.lineTo(archer.x+52, archer.y+archer.h+34); ctx.stroke();

    drawHead(headArcher, archer.x+26, archer.y-16, 22);

    ctx.strokeStyle='#d9b99a'; ctx.lineWidth=6; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(archer.x+18, archer.y-8); ctx.lineTo(archer.x+56, archer.y+16); ctx.stroke();

    const anchor = { x: archer.x+24, y: archer.y-26 };
    const hand = archer.aim ? archer.drawHand : anchor;
    ctx.beginPath(); ctx.moveTo(archer.x+20, archer.y-10); ctx.lineTo(hand.x, hand.y); ctx.stroke();

    ctx.strokeStyle='#6b3d24'; ctx.lineWidth=6; ctx.beginPath(); ctx.arc(archer.x+36, archer.y+20, 54, -Math.PI/2, Math.PI/2); ctx.stroke();
    ctx.strokeStyle='#caa27f'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(archer.x+36, archer.y-34); ctx.lineTo(hand.x, hand.y); ctx.lineTo(archer.x+36, archer.y+74); ctx.stroke();
  }

  function drawNockedArrow(){
    const anchor = { x: archer.x+24, y: archer.y-26 };
    const hand = archer.drawHand;
    const dir = Math.atan2(hand.y - anchor.y, hand.x - anchor.x);
    const pos = { x: hand.x + Math.cos(dir)*-6, y: hand.y + Math.sin(dir)*-6 };
    drawArrowShape(pos.x, pos.y, dir);
  }

  function drawCageAndLover(){
    ctx.fillStyle='#b0a79a'; roundRect(cage.x, cage.y, cage.w, cage.h, 10); ctx.fill();
    ctx.strokeStyle='#6f675b'; ctx.lineWidth=3;
    for(let i=0;i<5;i++){ const gx=cage.x+10+i*24; ctx.beginPath(); ctx.moveTo(gx,cage.y+10); ctx.lineTo(gx,cage.y+cage.h-10); ctx.stroke(); }
    if(cage.open){ ctx.save(); ctx.translate(cage.x+cage.w-16, cage.y+12); ctx.rotate(-Math.PI/2.4); ctx.fillStyle='#a79f93'; roundRect(0,0,12,cage.h-24,4); ctx.fill(); ctx.restore(); }
    else { ctx.fillStyle='#a79f93'; roundRect(cage.x+cage.w-24, cage.y+12, 12, cage.h-24, 4); ctx.fill(); }

    const baseX=lover.x, baseY=lover.y - Math.sin(performance.now()/160)*lover.jumpAmp;
    ctx.strokeStyle='#33402f'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(baseX, baseY-16); ctx.lineTo(baseX, baseY+22); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(baseX, baseY); ctx.lineTo(baseX-12, baseY+10);
    ctx.moveTo(baseX, baseY); ctx.lineTo(baseX+12, baseY+10); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(baseX, baseY+22); ctx.lineTo(baseX-10, baseY+42);
    ctx.moveTo(baseX, baseY+22); ctx.lineTo(baseX+10, baseY+42); ctx.stroke();
    drawHead(headLover, baseX, baseY-28, 16);
  }

  function drawEnemy(en){
    ctx.save(); ctx.translate(en.x, en.y); if(en.falling) ctx.rotate(en.rot);
    ctx.fillStyle='#9b4dca22'; ctx.beginPath(); ctx.arc(0,6,en.r+10,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#9b4dca'; ctx.beginPath(); ctx.arc(0,0,en.r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(-6,-4,4,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(6,-4,4,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#222'; ctx.beginPath(); ctx.arc(-6,-4,2,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(6,-4,2,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#b089d6'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(-en.r,0); ctx.quadraticCurveTo(-en.r-18,-14,-en.r-28,0); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(en.r,0); ctx.quadraticCurveTo(en.r+18,-14,en.r+28,0); ctx.stroke();
    ctx.restore();
  }

  // Bezier + draw arrow
  function bezierPoint(a,t){ const u=1-t; return { x:u*u*u*a.from.x + 3*u*u*t*a.c1.x + 3*u*t*t*a.c2.x + t*t*t*a.to.x,
                                                   y:u*u*u*a.from.y + 3*u*u*t*a.c1.y + 3*u*t*t*a.c2.y + t*t*t*a.to.y }; }
  function drawArrow(a){
    const p = bezierPoint(a,a.t);
    const amp = a.wobAmp * Math.pow(0.85, a.t*6);
    const wx = Math.cos(a.t*a.wobFreq*Math.PI)*amp*0.25;
    const wy = Math.sin(a.t*a.wobFreq*Math.PI)*amp;
    const x = p.x + wx, y = p.y + wy;
    const dx = x - a.lastPos.x, dy = y - a.lastPos.y;
    a.angle = Math.atan2(dy, dx); a.lastPos = {x,y};
    drawArrowShape(x, y, a.angle);
  }
  function drawArrowShape(x, y, angle){
    ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
    ctx.fillStyle = '#6b4b2a'; ctx.fillRect(-26, -2, 30, 4);
    ctx.fillStyle = '#d9b38c'; ctx.beginPath(); ctx.moveTo(-30, 0); ctx.lineTo(-38, -7); ctx.lineTo(-32, 0); ctx.lineTo(-38, 7); ctx.closePath(); ctx.fill();
    ctx.fillStyle = '#5a3b27'; ctx.beginPath(); ctx.moveTo(6, 0); ctx.lineTo(-2, -6); ctx.lineTo(-2, 6); ctx.closePath(); ctx.fill();
    ctx.restore();
  }

  // Hit
  function hit(a){
    const candidates = enemies.map((e,i)=>({e,i})).filter(o=>o.e.alive && !o.e.falling && !o.e.landed);
    if(!candidates.length) return;
    let best=candidates[0], bd=1e9;
    candidates.forEach(o=>{ const d2=(o.e.x-a.to.x)**2+(o.e.y-a.to.y)**2; if(d2<bd){ bd=d2; best=o; } });
    const en=best.e; en.falling=true;
    try{ hitSfx.currentTime=0; hitSfx.play().catch(()=>{});}catch{}
    lover.jumpAmp = Math.min(18, lover.jumpAmp+10);
    hits++; hitsEl.textContent = hits;
    const remain = enemies.filter(e=>e.alive && !e.falling && !e.landed).length;
    remainEl.textContent = remain;
    if(remain===0 && !victory){ cage.open=true; victory=true; tVictory=performance.now(); }
  }

  // Ôm/hôn
  function drawHug(){
    const hx = archer.x + 64, hy = archer.y - 6;
    const t = (performance.now()-hugStart)/1000, bounce = Math.sin(t*8)*3;

    // archer
    ctx.strokeStyle='#33402f'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(hx-14, hy-8+bounce); ctx.lineTo(hx-14, hy+30+bounce); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(hx-14, hy+6+bounce); ctx.quadraticCurveTo(hx, hy+2+bounce, hx+14, hy+10+bounce); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(hx-14, hy+30+bounce); ctx.lineTo(hx-26, hy+54+bounce);
    ctx.moveTo(hx-14, hy+30+bounce); ctx.lineTo(hx-2, hy+54+bounce); ctx.stroke();
    drawHead(headArcher, hx-16, hy-22+bounce, 18);

    // lover
    ctx.beginPath(); ctx.moveTo(hx+14, hy-8+bounce); ctx.lineTo(hx+14, hy+30+bounce); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(hx+14, hy+6+bounce); ctx.quadraticCurveTo(hx, hy+2+bounce, hx-14, hy+10+bounce); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(hx+14, hy+30+bounce); ctx.lineTo(hx+26, hy+54+bounce);
    ctx.moveTo(hx+14, hy+30+bounce); ctx.lineTo(hx+2, hy+54+bounce); ctx.stroke();
    drawHead(headLover, hx+16, hy-22+bounce, 18);
  }

  // Hearts + hon bursts
  function spawnHeart(x,y){
    const rect = cvs.getBoundingClientRect();
    const node = document.createElement('div');
    node.style.position='fixed';
    node.style.left = (rect.left + (x/W)*rect.width) + 'px';
    node.style.top  = (rect.top  + (y/H)*rect.height) + 'px';
    node.style.width='18px'; node.style.height='18px'; node.style.pointerEvents='none';
    node.style.transform='translate(-50%,-50%)'; node.style.zIndex='9';
    node.innerHTML = `<svg viewBox="0 0 24 24" width="18" height="18"><path fill="${'#ff6b81'}" d="M12 21s-6.716-4.438-9.333-7.056C.59 11.87.59 8.63 2.667 6.556c1.477-1.476 3.872-1.74 5.667-.64 1.795-1.1 4.19-.836 5.667.64 2.077 2.074 2.077 5.314 0 7.388C18.716 16.562 12 21 12 21z"/></svg>`;
    document.body.appendChild(node);
    const dy = -70 - Math.random()*40, dx = (Math.random()*40-20);
    node.animate([
      { transform:'translate(-50%,-50%) scale(0.9)', opacity:0.95 },
      { transform:`translate(${dx-50}%, ${dy-50}%) scale(1.2)`, opacity:0 }
    ], { duration: 1200, easing:'ease-out' }).onfinish = ()=> node.remove();
  }
  function honBurst(x,y){
    const rect = cvs.getBoundingClientRect();
    for(let i=0;i<10;i++){
      const a = document.createElement('img');
      a.src = 'hon.png'; a.className = 'hon';
      a.style.left = (rect.left + (x/W)*rect.width) + 'px';
      a.style.top  = (rect.top  + (y/H)*rect.height) + 'px';
      document.body.appendChild(a);
      const dx = (Math.random()*200-100), dy = (-120 - Math.random()*100);
      a.animate([
        { transform:'translate(-50%,-50%) scale(0.8)', opacity:0.95 },
        { transform:`translate(${dx-50}%, ${dy-50}%) rotate(${(Math.random()*60-30)}deg) scale(0.9)`, opacity:0 }
      ], { duration: 1400, easing:'ease-out' }).onfinish = ()=> a.remove();
    }
  }

  // HELP bubble
  function spawnHelpBubble(){
    const rect = cvs.getBoundingClientRect();
    const cageCenterX = cage.x + cage.w/2;
    const startX = rect.left + (cageCenterX/W)*rect.width + (Math.random()*40-20);
    const startY = rect.top  + ((cage.y+20)/H)*rect.height;

    const el = document.createElement('div');
    el.className = 'help';
    el.textContent = 'HELP';
    el.style.left = startX + 'px';
    el.style.top  = startY + 'px';
    document.body.appendChild(el);

    const up = -120 - Math.random()*60, drift = (Math.random()*60-30);
    el.animate([
      { transform:'translate(-50%,-50%) scale(0.9)', opacity:0.95 },
      { transform:`translate(${drift-50}%, ${up-50}%) scale(1.1)`, opacity:0 }
    ], { duration: 1400, easing:'ease-out' }).onfinish = ()=> el.remove();
  }

  // ====== QUIZ ======
  function showQuiz(){
    quizOverlay.style.display = 'flex';
    // phát voice & hiện mặt xuanhoang "đang nói"
    try{
      voiceQ.currentTime=0;
      voiceQ.play().then(()=>{
        talker.style.display='flex';
        talkFace.classList.add('talking');
      }).catch(()=>{});
    }catch{}
  }
  voiceQ.addEventListener('ended', ()=>{ talkFace.classList.remove('talking'); });
  voiceQ.addEventListener('pause',  ()=>{ talkFace.classList.remove('talking'); });

  quizOverlay.addEventListener('click', (e)=>{
    const btn = e.target.closest('.choice'); if(!btn) return;
    const ans = btn.getAttribute('data-a');
    if(ans === 'tiramisu'){
      try{ voiceQ.pause(); }catch{}
      try{ victorySong.currentTime=0; victorySong.play().catch(()=>{});}catch{}
      try{ chutSfx.currentTime=0; chutSfx.play().catch(()=>{});}catch{}
      quizLead.textContent = "Anh giỏi quá! 💖";
      const kissX = archer.x + 64, kissY = archer.y - 6;
      honBurst(kissX, kissY); for(let i=0;i<10;i++) spawnHeart(kissX, kissY-20);
      // ✅ chuyển sang 06.html sau hiệu ứng
      setTimeout(()=>{ window.location.href = "06.html"; }, 1800);
    } else {
      const dlg = quizOverlay.querySelector('.dialog');
      dlg.animate([{transform:'translateX(0)'},{transform:'translateX(-6px)'},{transform:'translateX(6px)'},{transform:'translateX(0)'}],{duration:300});
    }
  });

  // ====== Start (FIX vòng lặp) ======
  function startGame(){
    if(running) return;
    running = true;                 // ✅ BẬT cờ chạy
    requestAnimationFrame(loop);    // ✅ Gọi frame đầu tiên
  }

})();
</script>
</body>
</html>
